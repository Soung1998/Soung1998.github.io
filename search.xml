<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础-java值传递]]></title>
    <url>%2F2019%2F03%2F30%2Fjava%E5%9F%BA%E7%A1%80-java%E5%80%BC%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[总结java中方法参数传递方式是按值传递。如果参数是基本类型，传递的是基本类型的字面量值的拷贝。如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。 代码示例1234567891011121314151617181920212223242526272829303132333435363738public class ReferencePkValue2 &#123; static class MyObj&#123; int num; public MyObj(int num) &#123; this.num = num; &#125; public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125; &#125; public static void main(String[] args) &#123; ReferencePkValue2 t = new ReferencePkValue2(); int a=99; t.test1(a);//这里传递的参数a就是按值传递 System.out.println(a); MyObj obj = new MyObj(111); t.test2(obj);//引用类型，这里传递的参数obj就是引用的拷贝 System.out.println(obj.num); &#125; public void test1(int a)&#123; a=a+1; System.out.println(a); &#125; public void test2(MyObj obj)&#123; obj.num=100; System.out.println(obj.num); &#125;&#125; 运行结果123410099100100]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-String、StringBuilder和StringBuffer]]></title>
    <url>%2F2019%2F03%2F21%2Fjava%E5%9F%BA%E7%A1%80-String%E3%80%81StringBuilder%E5%92%8CStringBuffer%2F</url>
    <content type="text"><![CDATA[运行速度的区别 运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String String最慢的原因： String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。 但是在自己的实际编程中发现其实String对象是可“更改”的，原因如下1234String str="abc";System.out.println(str);str=str+"de";System.out.println(str); 其实str只是被覆盖了如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。 线程安全在线程安全上，StringBuffer是线程安全的。StringBuilder是线程不安全的,在单线程中性能要比StringBuffrer高。 例如：《Think in Java》中，描述HashTable和HashMap区别一样，就是因为HashTable支持线程同步、保证线程安全而导致的性能下降。 HashTable是线程安全的，很多方法都是synchronized方法。 HashMap不是线程安全的，但在单线程程序中的性能比HashTable要高。 适用场合String：适用于少量的字符串操作的情况 StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况 StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-枚举]]></title>
    <url>%2F2019%2F03%2F16%2Fjava%E5%9F%BA%E7%A1%80-%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[枚举当一个变量有几种可能的取值时，可以将它定义为枚举类型。 使用场景1在实际的工作中，比如我有一个选择家庭关系的下拉选择框，大家都是会是value和desc的组合，一般我们保存到数据库的都是value（英文），然后用户看到的是desc（中文）。但是我很多个页面会用到这样的下拉框，甚至可能很多个系统会用到，需要保持数据源的一致性，因此可以用一个枚举保存起来，然后提供一个接口，所有前端展示的数据源都是从这个接口里面获取。 1、作为普通的常量使用，如星期、季节等,通常配合switch语句使用。2、往枚举中添加变量、构造函数、以达到灵活获取指定值的目的（注： Java 要求必须先定义 enum实例，否则编译会报错）；通常用于一些业务系统中定义一些固定值，如用于匹配db中的字段值等。 枚举类的构造函数必须是私有的，因为枚举是单例模式，枚举类型在jvm加载时就实例化枚举对象，后续无法再new新的枚举对象（会破坏唯一性）12345678910111213141516171819202122232425262728293031323334353637383940414243444546public enum SeasonEnum &#123; //实例的定义必须放在最前 SPRING(1,"spring"), SUMMER(2,"夏天"), AUTUMN(3,"秋天"), WINTER(4,"冬天"); private int state; private String desc; /* int对应上面的1,2,3,4,；String对应上面的文字描述 必须一一对应,参数可以有一个或者多个取决于实例的参数内容 */ private SeasonEnum(int state,String desc)&#123; this.state=state; this.desc=desc; &#125; //一般不允许外界修改枚举类型的内容，故不用写set方法 public int getState() &#123; return state; &#125; public String getDesc() &#123; return desc; &#125; //根据传入的state值返回相应的enum public static SeasonEnum stateof(int state)&#123; for (SeasonEnum stateEnum : SeasonEnum.values())&#123; if (stateEnum.getState() == state)&#123; return stateEnum; &#125; &#125; return null; &#125; //主函数仅做测试使用 public static void main(String []args)&#123; //System.out.print(SeasonEnum.values()); for (SeasonEnum seasonEnum : SeasonEnum.values())&#123; System.out.println(seasonEnum.getState()+":"+seasonEnum.getDesc()); &#125; &#125;&#125; 在外部程序若要使用枚举类型直接调用如下1System.out.print(SeasonEnum.SPRING.getDesc()); 枚举类enum的values()方法123System.out.print(SeasonEnum.values());//结果为[LSeasonEnum;@4a574795 1234SeasonEnum[] arr = SeasonEnum.values(); System.out.print(arr[0]); //结果为 SPRING1:spring 12345678for (SeasonEnum seasonEnum : SeasonEnum.values())&#123; System.out.println(seasonEnum.getState()+":"+seasonEnum.getDesc()); &#125; //结果为，idea编译器没修改统一的UTF-8而乱码 1:spring2:澶忓ぉ3:绉嬪ぉ4:鍐ぉ]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm配置文件]]></title>
    <url>%2F2019%2F03%2F15%2Fssm%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[整合SpringMVC，spring和mybatis框架所需要配置的配置文件。 web.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件,如果没有这个参数，Spring默认加载web-inf/applicationContext.xml文件。--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 匹配所有请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; springmvc.xml12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"&gt; &lt;!-- 扫描web相关的bean --&gt; &lt;context:component-scan base-package="××.××.controller"/&gt; &lt;!-- 开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源默认servlet配置 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 拦截器（若有可选） --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/*"/&gt; &lt;bean class="cn.wmyskxz.interceptor.LoginInterceptor"/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/*"/&gt; &lt;bean class="cn.wmyskxz.interceptor.OtherInterceptor"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>ssm</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC-拦截器]]></title>
    <url>%2F2019%2F03%2F14%2FSpringMVC-%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[处理器拦截器简介Spring Web MVC的处理器拦截器（如无特殊说明，下文所说的拦截器即处理器拦截器）类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。 常见应用场景1、日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等。2、权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面。3、性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间（如果有反向代理，如apache可以自动记录）。4、通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。5、OpenSessionInView：如Hibernate，在进入处理器打开Session，在完成后关闭Session。 本质也是AOP（面向切面编程），也就是说符合横切关注点的所有功能都可以放入拦截器实现。 拦截器的执行过程执行顺序图片详解当页面的request请求发送过来,由前端控制器DispatcherServlet来控制,交给对应的Controller进行请求的处理,但是在处理之前,要先经过拦截器的拦截(如果配置了的话)。 源码1234567891011121314151617package org.springframework.web.servlet; public interface HandlerInterceptor &#123; boolean preHandle( HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception; void afterCompletion( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception; &#125; preHandle：预处理回调方法，实现处理器的预处理（如登录检查），第三个参数为响应的处理器（如我们上一章的Controller实现）； 返回值：true表示继续流程（如调用下一个拦截器或处理器）； false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应； postHandle：后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。 afterCompletion：整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion。 拦截器链拦截器在spring-configs.xml中的配置顺序即规定了拦截器链中各个拦截器的执行顺序。]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-序列化]]></title>
    <url>%2F2019%2F03%2F09%2Fjava%E5%9F%BA%E7%A1%80-%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[详见–&gt;Java基础学习总结——Java对象的序列化和反序列化 一、序列化和反序列化概念 把对象转换为字节序列的过程称为对象的序列化。 把字节序列恢复为对象的过程称为对象的反序列化。 用途 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中。(如：把web容器中的Session对象序列化到硬盘中，使用时再调入内存) 在网络上传送对象的字节序列。（进程通信） 当你想通过RMI调用对象时（RMI是什么东西？）：RMI总结来说就是远程调用对象，在一个jvm上调用另一个jvm的对象。应用场景sessio可以存储在很多位置，并不是固定在某个地方。可能是内存，也可以是硬盘，服务器关闭后，session暂时还不会失效，比如登录页面，如果服务器关闭了，session还没失效，但是开启服务器后，希望还是看到之前登录的用户登录进去的页面，这时候需要序列化改pojo对象，这样pojo对象会跟session一起保存到内存或者硬盘。而重新开启服务器后，session和pojo会重新被加载，原来的pojo对象也会重新显现出来。所以说session对象的序列化是为了保持对象处于一种状态。 即序列化的作用就是：为了保存在内存中的各种对象的状态（序列化），并且可以把保存的对象状态再读出来（反序列化）。 二、序列化和反序列化的简单实现定义person类，实现Serializaable接口1234567891011121314151617181920import java.io.Serializable;public class person implements Serializable &#123; private static final long serialVersionUID = 1L; private int id; private int age; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 序列化和反序列化Person类对象1234567891011121314151617181920212223242526272829303132import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.text.MessageFormat;public class test &#123; public static void main(String[] args) throws Exception, IOException &#123; SerializePerson();//序列化对象 person p = DeserializePerson();//接收反序列化结果 System.out.print(MessageFormat.format("id=&#123;0&#125;,age=&#123;1&#125;",p.getId(),p.getAge())); &#125; private static void SerializePerson() throws FileNotFoundException, IOException&#123; person p1 = new person(); p1.setId(1); p1.setAge(18); //将p1序列化到D盘中，并生成文件储存序列化结果 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File("D:/person.txt"))); oos.writeObject(p1); System.out.println("person对象序列化成功！"); oos.close(); &#125; private static person DeserializePerson() throws Exception, IOException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File("D:/person.txt"))); person p2 = (person) ois.readObject(); System.out.println("person对象反序列化成功！"); return p2; &#125;&#125; 运行结果123person对象序列化成功！person对象反序列化成功！id=1,age=18 序列化person成功后在D盘生成了一个person.txt文件，而反序列化person是读取D盘的person.txt后生成了一个person对象 三、serialVersionUID生成方式1.默认生成1private static final long serialVersionUID = 1L; 2.根据类名，接口名，方法和属性等来生成需要插件和设置环境–&gt;idea自动生成serialVersionUID（建议使用该方法）1private static final long serialVersionUID = 4603642343377807741L; 原因：意思就是说，文件流中的class和classpath中的class，也就是修改过后的class，不兼容了，处于安全机制考虑，程序抛出了错误，并且拒绝载入。那么如果我们真的有需求要在序列化后添加一个字段或者方法呢？应该怎么办？那就是自己去指定serialVersionUID。在TestSerialversionUID例子中，没有指定Customer类的serialVersionUID的，那么java编译器会自动给这个class进行一个摘要算法，类似于指纹算法，只要这个文件 多一个空格，得到的UID就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以，添加了一个字段后，由于没有显指定 serialVersionUID，编译器又为我们生成了一个UID，当然和前面保存在文件中的那个不会一样了，于是就出现了2个序列化版本号不一致的错误。因此，只要我们自己指定了serialVersionUID，就可以在序列化后，去添加一个字段，或者方法，而不会影响到后期的还原，还原后的对象照样可以使用，而且还多了方法或者属性可以用。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-线程]]></title>
    <url>%2F2019%2F03%2F07%2Fjava%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[（尚待补充）什么是线程 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 为什么要使用多线程线程可以理解成是在进程中独立运行的子任务。比如QQ.exe运行时就会有很多的子任务在同时运行。比如，好友视频线程、下载文件线程、传输数据线程、发送表情线程等。这些不同的任务或者说功能都可以同时运行，其中每一个任务完全可以理解成是“线程”在工作，传文件、听音乐、发送图片表情等功能都有对应的线程在后台默默地运行。任务1（用时10秒）和任务2（用时1秒）是两个完全独立、互不相关的两个任务。 在单任务环境下，任务1等待远程服务器返回数据，以便进行后期的处理，这是CPU一直处于等待状态，如果任务2是10s之后被运行，虽然任务2用的时间仅有1秒，但也必须在任务1结束后才能运行任务2。单任务的特点就是排队执行，也就是同步，就像在cmd中输入一条命令后，必须等待这条命令执行完才可以执行下一条命令一样。这就是单任务环境的缺点，即CPU利用率非常低。 在多任务环境下，CPU完全可以在任务1和任务2之间来回切换，使任务2不必等到10s再运行。CPU的利用率大大提高。这就是要使用多线程技术、要学习多线程的原因。这是多线程的优点，使用多线程也就是在使用异步。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-泛型]]></title>
    <url>%2F2019%2F03%2F07%2Fjava%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型定义Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。菜鸟教程链接 个人理解 常用于配合集合类型使用，使得类和方法可接受不同的数据类型，并且在编译时候提供纠错机制 简单举例在一个简单的Box类中只能接收String类型的参数，代码如下：12345public class Box &#123; private String object; public void set(String object) &#123; this.object = object; &#125; public String get() &#123; return object; &#125;&#125; 而使用泛型之后，该类可以接收各种无限制类型的参数，代码如下：12345public class Box&lt;T&gt; &#123; //其中T代表可以装入的无限制的参数 private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125;&#125; 如此该类可以得到复用，我们可以将T替换成任何我们想要的类型：123Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();Box&lt;Double&gt; doubleBox = new Box&lt;Double&gt;();Box&lt;String&gt; stringBox = new Box&lt;String&gt;(); （注：使用泛型方法注意边界符） 类型通配符1、无限制接收参数类型通配符一般是使用?代替具体的类型参数。例如 List&lt;?&gt; 在逻辑上是List,List 等所有List&lt;具体类型实参&gt;的父类。1234567891011121314151617181920212223import java.util.*; public class GenericTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; name = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;Integer&gt;(); List&lt;Number&gt; number = new ArrayList&lt;Number&gt;(); name.add("icon"); age.add(18); number.add(314); getData(name); getData(age); getData(number); &#125; public static void getData(List&lt;?&gt; data) &#123; System.out.println("data :" + data.get(0)); &#125;&#125; 输出结果为：123data :icondata :18data :314 2、类型通配符上限（过滤部分参数）通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型123456789101112131415161718192021222324252627import java.util.*; public class GenericTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; name = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;Integer&gt;(); List&lt;Number&gt; number = new ArrayList&lt;Number&gt;(); name.add("icon"); age.add(18); number.add(314); //getUperNumber(name);//1 getUperNumber(age);//2 getUperNumber(number);//3 &#125; public static void getData(List&lt;?&gt; data) &#123; System.out.println("data :" + data.get(0)); &#125; public static void getUperNumber(List&lt;? extends Number&gt; data) &#123; System.out.println("data :" + data.get(0)); &#125;&#125; 输出结果：12data :18data :314 3、类型通配符下限通过形如 List&lt;? super Number&gt;来定义，表示类型只能接受Number及其三层父类类型，如Objec类型的实例。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitPages+Hexo搭建并开通博客]]></title>
    <url>%2F2019%2F03%2F05%2F%E4%BD%BF%E7%94%A8GitPages-Hexo%E6%90%AD%E5%BB%BA%E5%B9%B6%E5%BC%80%E9%80%9A%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[博客制作总结参考B站教学视频手把手教你搭建属于自己的hexo+github博客使用Next主题来进行优化改造 1、工具准备：node.js和Git的安装2、安装 Sublime text 3作为编辑各种文件的工具 Sublime text 3 下载地址 3、创建GitHub仓库 Repository name：注册用户名.github.io（.github.io为强制要求） Description（仓库描述）：选填。 Public：勾选，表示可以供他人访问。 Initialize this repository with a README：可选。最后点击 create repository 即可。 4、配置GitHubSSH将本地项目部署到GitHub，修改站点下的_config.yml文件1234deploy: type: git repo: git@github.com:Soung1998/Soung1998.github.io.git branch: master 5、常用Git命令（备忘）1234hexo clean //有时候出调试没反应可以尝试清除缓存hexo s //打开服务hexo g //再键入hexo d 为将本地项目更新部署到GitHub上hexo d 6、Next主题使用这里采用使用比较多的主题：NexT主题。参考博客的第二个视频。]]></content>
      <categories>
        <category>博客制作</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>博客制作</tag>
      </tags>
  </entry>
</search>
