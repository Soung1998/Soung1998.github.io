<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础-序列化]]></title>
    <url>%2F2019%2F03%2F09%2Fjava%E5%9F%BA%E7%A1%80-%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[详见–&gt;Java基础学习总结——Java对象的序列化和反序列化 一、序列化和反序列化概念 把对象转换为字节序列的过程称为对象的序列化。 把字节序列恢复为对象的过程称为对象的反序列化。 用途 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中。(如：把web容器中的Session对象序列化到硬盘中，使用时再调入内存) 在网络上传送对象的字节序列。（进程通信） 二、序列化和反序列化的简单实现定义person类，实现Serializaable接口1234567891011121314151617181920import java.io.Serializable;public class person implements Serializable &#123; private static final long serialVersionUID = 1L; private int id; private int age; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 序列化和反序列化Person类对象1234567891011121314151617181920212223242526272829303132import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.text.MessageFormat;public class test &#123; public static void main(String[] args) throws Exception, IOException &#123; SerializePerson();//序列化对象 person p = DeserializePerson();//接收反序列化结果 System.out.print(MessageFormat.format("id=&#123;0&#125;,age=&#123;1&#125;",p.getId(),p.getAge())); &#125; private static void SerializePerson() throws FileNotFoundException, IOException&#123; person p1 = new person(); p1.setId(1); p1.setAge(18); //将p1序列化到D盘中，并生成文件储存序列化结果 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File("D:/person.txt"))); oos.writeObject(p1); System.out.println("person对象序列化成功！"); oos.close(); &#125; private static person DeserializePerson() throws Exception, IOException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File("D:/person.txt"))); person p2 = (person) ois.readObject(); System.out.println("person对象反序列化成功！"); return p2; &#125;&#125; 运行结果123person对象序列化成功！person对象反序列化成功！id=1,age=18 序列化person成功后在D盘生成了一个person.txt文件，而反序列化person是读取D盘的person.txt后生成了一个person对象 三、serialVersionUID生成方式1.默认生成1private static final long serialVersionUID = 1L; 2.根据类名，接口名，方法和属性等来生成需要插件和设置环境–&gt;idea自动生成serialVersionUID（建议使用该方法）1private static final long serialVersionUID = 4603642343377807741L; 原因：意思就是说，文件流中的class和classpath中的class，也就是修改过后的class，不兼容了，处于安全机制考虑，程序抛出了错误，并且拒绝载入。那么如果我们真的有需求要在序列化后添加一个字段或者方法呢？应该怎么办？那就是自己去指定serialVersionUID。在TestSerialversionUID例子中，没有指定Customer类的serialVersionUID的，那么java编译器会自动给这个class进行一个摘要算法，类似于指纹算法，只要这个文件 多一个空格，得到的UID就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以，添加了一个字段后，由于没有显指定 serialVersionUID，编译器又为我们生成了一个UID，当然和前面保存在文件中的那个不会一样了，于是就出现了2个序列化版本号不一致的错误。因此，只要我们自己指定了serialVersionUID，就可以在序列化后，去添加一个字段，或者方法，而不会影响到后期的还原，还原后的对象照样可以使用，而且还多了方法或者属性可以用。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-线程]]></title>
    <url>%2F2019%2F03%2F07%2Fjava%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[（尚待补充）什么是线程 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 为什么要使用多线程线程可以理解成是在进程中独立运行的子任务。比如QQ.exe运行时就会有很多的子任务在同时运行。比如，好友视频线程、下载文件线程、传输数据线程、发送表情线程等。这些不同的任务或者说功能都可以同时运行，其中每一个任务完全可以理解成是“线程”在工作，传文件、听音乐、发送图片表情等功能都有对应的线程在后台默默地运行。任务1（用时10秒）和任务2（用时1秒）是两个完全独立、互不相关的两个任务。 在单任务环境下，任务1等待远程服务器返回数据，以便进行后期的处理，这是CPU一直处于等待状态，如果任务2是10s之后被运行，虽然任务2用的时间仅有1秒，但也必须在任务1结束后才能运行任务2。单任务的特点就是排队执行，也就是同步，就像在cmd中输入一条命令后，必须等待这条命令执行完才可以执行下一条命令一样。这就是单任务环境的缺点，即CPU利用率非常低。 在多任务环境下，CPU完全可以在任务1和任务2之间来回切换，使任务2不必等到10s再运行。CPU的利用率大大提高。这就是要使用多线程技术、要学习多线程的原因。这是多线程的优点，使用多线程也就是在使用异步。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-泛型]]></title>
    <url>%2F2019%2F03%2F07%2Fjava%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型定义Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。菜鸟教程链接 个人理解 常用于配合集合类型使用，使得类和方法可接受不同的数据类型，并且在编译时候提供纠错机制 简单举例在一个简单的Box类中只能接收String类型的参数，代码如下：12345public class Box &#123; private String object; public void set(String object) &#123; this.object = object; &#125; public String get() &#123; return object; &#125;&#125; 而使用泛型之后，该类可以接收各种无限制类型的参数，代码如下：12345public class Box&lt;T&gt; &#123; //其中T代表可以装入的无限制的参数 private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125;&#125; 如此该类可以得到复用，我们可以将T替换成任何我们想要的类型：123Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();Box&lt;Double&gt; doubleBox = new Box&lt;Double&gt;();Box&lt;String&gt; stringBox = new Box&lt;String&gt;(); （注：使用泛型方法注意边界符） 类型通配符1、无限制接收参数类型通配符一般是使用?代替具体的类型参数。例如 List&lt;?&gt; 在逻辑上是List,List 等所有List&lt;具体类型实参&gt;的父类。1234567891011121314151617181920212223import java.util.*; public class GenericTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; name = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;Integer&gt;(); List&lt;Number&gt; number = new ArrayList&lt;Number&gt;(); name.add("icon"); age.add(18); number.add(314); getData(name); getData(age); getData(number); &#125; public static void getData(List&lt;?&gt; data) &#123; System.out.println("data :" + data.get(0)); &#125;&#125; 输出结果为：123data :icondata :18data :314 2、类型通配符上限（过滤部分参数）通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型123456789101112131415161718192021222324252627import java.util.*; public class GenericTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; name = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;Integer&gt;(); List&lt;Number&gt; number = new ArrayList&lt;Number&gt;(); name.add("icon"); age.add(18); number.add(314); //getUperNumber(name);//1 getUperNumber(age);//2 getUperNumber(number);//3 &#125; public static void getData(List&lt;?&gt; data) &#123; System.out.println("data :" + data.get(0)); &#125; public static void getUperNumber(List&lt;? extends Number&gt; data) &#123; System.out.println("data :" + data.get(0)); &#125;&#125; 输出结果：12data :18data :314 3、类型通配符下限通过形如 List&lt;? super Number&gt;来定义，表示类型只能接受Number及其三层父类类型，如Objec类型的实例。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitPages+Hexo搭建并开通博客]]></title>
    <url>%2F2019%2F03%2F05%2F%E4%BD%BF%E7%94%A8GitPages-Hexo%E6%90%AD%E5%BB%BA%E5%B9%B6%E5%BC%80%E9%80%9A%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[博客制作总结参考B站教学视频手把手教你搭建属于自己的hexo+github博客使用Next主题来进行优化改造 1、工具准备：node.js和Git的安装2、安装 Sublime text 3作为编辑各种文件的工具 Sublime text 3 下载地址 3、创建GitHub仓库 Repository name：注册用户名.github.io（.github.io为强制要求） Description（仓库描述）：选填。 Public：勾选，表示可以供他人访问。 Initialize this repository with a README：可选。最后点击 create repository 即可。 4、配置GitHubSSH将本地项目部署到GitHub，修改站点下的_config.yml文件1234deploy: type: git repo: git@github.com:Soung1998/Soung1998.github.io.git branch: master 5、常用Git命令（备忘）1234hexo clean //有时候出调试没反应可以尝试清除缓存hexo s //打开服务hexo g //再键入hexo d 为将本地项目更新部署到GitHub上hexo d 6、Next主题使用这里采用使用比较多的主题：NexT主题。参考博客的第二个视频。]]></content>
      <categories>
        <category>博客制作</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>博客制作</tag>
      </tags>
  </entry>
</search>
